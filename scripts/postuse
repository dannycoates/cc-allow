#!/bin/bash
set -e

PLUGIN_ROOT="${CLAUDE_PLUGIN_ROOT:-$(dirname "$(dirname "$0")")}"
BIN="${PLUGIN_ROOT}/bin/cc-allow"
if [ ! -x "$BIN" ]; then
  BIN="${PLUGIN_ROOT}/cc-allow"  # local dev fallback
fi
if [ ! -x "$BIN" ]; then
  exit 0  # no binary, exit silently (install is SessionStart's job)
fi

# Need jq to parse JSON
if ! command -v jq &> /dev/null; then
  exit 0
fi

# Read full PostToolUse JSON from stdin
HOOK_JSON=$(cat)

# Re-evaluate: pipe JSON to cc-allow --hook
# Go decoder ignores extra PostToolUse fields (tool_response, hook_event_name, etc.)
# cc-allow reads session_id from JSON and loads the session config chain automatically
RESULT=$(echo "$HOOK_JSON" | "$BIN" --hook --post 2>/dev/null) || true
DECISION=$(echo "$RESULT" | jq -r '.hookSpecificOutput.permissionDecision // empty' 2>/dev/null) || true
REASON=$(echo "$RESULT" | jq -r '.hookSpecificOutput.permissionDecisionReason // empty' 2>/dev/null) || true

# Forward additionalContext to Claude Code (requires hookEventName for PostToolUse)
ADDITIONAL=$(echo "$RESULT" | jq -r '.hookSpecificOutput.additionalContext // empty' 2>/dev/null) || true
if [ -n "$ADDITIONAL" ]; then
  jq -n --arg ctx "$ADDITIONAL" '{"hookSpecificOutput":{"hookEventName":"PostToolUse","additionalContext":$ctx}}'
fi

# Only act on default "ask" â€” explicit ask rules are intentional
if [ "$DECISION" != "ask" ] || [[ "$REASON" != default:* ]]; then
  exit 0
fi

# Extract fields for the prompt
TOOL_NAME=$(echo "$HOOK_JSON" | jq -r '.tool_name // empty')
SESSION_ID=$(echo "$HOOK_JSON" | jq -r '.session_id // empty')
CWD=$(echo "$HOOK_JSON" | jq -r '.cwd // empty')

if [ -z "$TOOL_NAME" ] || [ -z "$SESSION_ID" ]; then
  exit 0
fi

# Build human-readable input description per tool type
# (avoid passing large blobs like Write file content)
case "$TOOL_NAME" in
  Bash)
    INPUT_DESC="command: \`$(echo "$HOOK_JSON" | jq -r '.tool_input.command // empty')\`" ;;
  Read|Write|Edit)
    INPUT_DESC="file path: \`$(echo "$HOOK_JSON" | jq -r '.tool_input.file_path // empty')\`" ;;
  WebFetch)
    INPUT_DESC="URL: \`$(echo "$HOOK_JSON" | jq -r '.tool_input.url // empty')\`" ;;
  Glob|Grep)
    P=$(echo "$HOOK_JSON" | jq -r '.tool_input.pattern // empty')
    D=$(echo "$HOOK_JSON" | jq -r '.tool_input.path // empty')
    INPUT_DESC="pattern='$P' path='$D'" ;;
  *) exit 0 ;;
esac

PROJECT_DIR="${CC_PROJECT_DIR:-${CLAUDE_PROJECT_DIR:-${CWD:-$(pwd)}}}"
SESSION_CONFIG="${PROJECT_DIR}/.config/cc-allow/sessions/${SESSION_ID}.toml"

# Ensure session config file exists with version header before invoking claude -p
if [ ! -f "$SESSION_CONFIG" ]; then
  mkdir -p "$(dirname "$SESSION_CONFIG")"
  printf 'version = "2.0"\n\n[bash.allow]\ncommands = []' > "$SESSION_CONFIG"
fi

# Construct prompt for claude -p
PROMPT="The user has allowed ${TOOL_NAME} ${INPUT_DESC}. Please update the session cc-allow config to allow it. The session id is ${SESSION_ID}. The session config is at ${SESSION_CONFIG}. Read any existing session configs first to avoid duplicates. The rule should not be too loose or specific. Create a rule based on the _intent_ that the user most likely expects. If there's another rule already in the config that's very similar generalize one to cover that type of invocation. IMPORTANT: File path globs must NEVER end with specific filenames or partial patterns (e.g. WRONG: 'path:\$PROJECT_ROOT/**/Cargo.toml', 'path:/home/user/**/*.lock'). Paths should specify as much of the root directory path as desired but ALWAYS end with '**' (e.g. RIGHT: 'path:\$PROJECT_ROOT/**', 'path:/home/user/.config/**').

IMPORTANT: Don't follow the default skill workflow, simply add the new rule(s) - do not test or provide an explanation, simply respond with 'done'"

case "$TOOL_NAME" in
  Bash)
    PROMPT+="

If the 'ask' was caused by a file path argument (e.g. 'head -20 /some/path', 'cat ~/.config/foo'), prefer adding a [read.allow], [write.allow], or [edit.allow] file rule over bash args."
    ;;
esac

# Spawn claude -p with allow-rules skill injected via system prompt
# After each attempt, re-evaluate with cc-allow to verify the rule matches.
# If it doesn't, retry with a stronger prompt (up to 2 attempts).
SKILL_FILE="${PLUGIN_ROOT}/skills/allow-rules/SKILL.md"
(
  cd "$PROJECT_DIR"
  MAX_RETRIES=2
  ATTEMPT=0
  EXTRA=""

  while [ $ATTEMPT -lt $MAX_RETRIES ]; do
    CLAUDE_CODE_SIMPLE=1 claude -p "${PROMPT}${EXTRA}" \
      --model haiku \
      --settings '{"disableAllHooks":true}' \
      --append-system-prompt-file "$SKILL_FILE" \
      --allowedTools "Read,Write,Edit,Bash" \
      --max-turns 12 \
      --no-session-persistence \
      > /dev/null 2>&1

    # Re-evaluate the original input against the updated config
    RECHECK=$(echo "$HOOK_JSON" | "$BIN" --hook 2>/dev/null) || true
    RECHECK_DECISION=$(echo "$RECHECK" | jq -r '.hookSpecificOutput.permissionDecision // empty' 2>/dev/null) || true

    if [ "$RECHECK_DECISION" = "allow" ]; then
      break
    fi

    ATTEMPT=$((ATTEMPT + 1))
    EXTRA="

IMPORTANT: An existing rule does NOT result in an 'allow' for this ${TOOL_NAME} invocation (${INPUT_DESC}). You MUST write a rule that matches this invocation. Be more general with patterns if needed. Read the session config at ${SESSION_CONFIG} and correct or add rules as necessary."
  done
) </dev/null >/dev/null 2>&1 &

exit 0
