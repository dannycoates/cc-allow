# Patterns ruleset - tests advanced pattern features
# Used to verify: negation, path patterns, positional args, specificity, heredocs, pipe wildcards

version = "2.0"

# ============================================================================
# ALIASES
# ============================================================================

[aliases]
project = "path:$PROJECT_ROOT/**"
etc = "path:/etc/**"

# ============================================================================
# BASH TOOL CONFIGURATION
# ============================================================================

[bash]
default = "ask"
dynamic_commands = "deny"

[bash.constructs]
function_definitions = "ask"
background = "ask"
subshells = "allow"
heredocs = "allow"  # allow heredocs so we can test heredoc rules

# ============================================================================
# ALLOWED COMMANDS
# ============================================================================

[bash.allow]
commands = ["echo", "ls", "cat", "head", "tail", "grep", "wc", "pwd", "true", "false"]

# ============================================================================
# DENIED COMMANDS
# ============================================================================

[bash.deny]
commands = ["sudo", "su"]
message = "Privilege escalation denied"

# ============================================================================
# PATTERN NEGATION TESTS
# ============================================================================

# Allow cat for any file EXCEPT those in /etc
[[bash.allow.cat]]
args.any = ["!path:/etc/**"]

# Deny cat for /etc files (more specific - should win over above)
[[bash.deny.cat]]
message = "Cannot read system config files"
args.any = ["path:/etc/**"]

# Deny grep when pattern looks like password
[[bash.deny.grep]]
message = "Cannot grep for password patterns"
args.any = ["re:(?i)password|secret|token"]

# ============================================================================
# PATH PATTERN TESTS WITH $PROJECT_ROOT
# ============================================================================

# Allow rm only within project (safe cleanup)
# Use args.any so flags like -rf don't break the match
[[bash.allow.rm]]
message = "Allowed: removing files within project"
args.any = ["alias:project"]

# Deny rm outside project
[[bash.deny.rm]]
message = "Cannot remove files outside project"

# Allow touch within project
[[bash.allow.touch]]
args.any = ["alias:project"]

# Deny touch outside project
[[bash.deny.touch]]
message = "Cannot create files outside project"

# ============================================================================
# POSITIONAL ARGUMENT TESTS
# ============================================================================

# Allow git with specific subcommands
[[bash.allow.git.status]]

[[bash.allow.git.diff]]

[[bash.allow.git.log]]

[[bash.allow.git.branch]]

# Deny git push/pull (network operations)
[[bash.deny.git]]
message = "Network git operations not allowed"
args.position = { "0" = "re:^(push|pull|fetch|clone)$" }

# Allow npm with read-only commands
[[bash.allow.npm]]
args.position = { "0" = "re:^(list|ls|view|info|help)$" }

# Deny npm install/publish (modifying operations)
[[bash.deny.npm]]
message = "npm modifying operations not allowed"
args.position = { "0" = "re:^(install|i|publish|unpublish)$" }

# ============================================================================
# SPECIFICITY TESTS
# More specific rules should win over less specific
# ============================================================================

# Generic: any command writing to .env files - ask
[[bash.ask."path:*"]]
message = "Writing to .env requires approval"
args.any = ["path:*.env", "path:.env*"]

# Specific: cp to .env - deny (more specific due to named command)
[[bash.deny.cp]]
message = "Cannot copy to .env files"
args.any = ["path:*.env", "path:.env*"]

# Very specific: mv with exact positions - allow (most specific)
[[bash.allow.mv]]
message = "Renaming .env.example to .env.local is allowed"
args.position = { "0" = ".env.example", "1" = ".env.local" }

# Less specific mv to .env - deny
[[bash.deny.mv]]
message = "Cannot move files to .env"
args.any = ["path:*.env", "path:.env*"]

# ============================================================================
# PIPE WILDCARD TESTS
# ============================================================================

# Deny eval receiving ANY piped input
[[bash.deny.eval]]
message = "eval cannot receive piped input"
pipe.from = ["path:*"]

# Deny source/. receiving any piped input
[[bash.deny.source]]
message = "source cannot receive piped input"
pipe.from = ["path:*"]

# Deny bash from specific dangerous sources
[[bash.deny.bash]]
message = "bash cannot receive input from download commands"
pipe.from = ["curl", "wget", "nc", "netcat"]

# ============================================================================
# HEREDOC CONTENT RULES
# ============================================================================

# Deny heredocs containing sudo/su commands
[[bash.heredocs.deny]]
message = "Heredoc contains privilege escalation"
content.any = ["re:(?m)^\\s*(sudo|su)\\s"]

# Deny heredocs that look like they're setting up reverse shells
[[bash.heredocs.deny]]
message = "Heredoc contains suspicious network code"
content.any = ["re:/dev/tcp/", "re:nc\\s+-e", "re:bash\\s+-i"]

# Deny heredocs containing rm -rf
[[bash.heredocs.deny]]
message = "Heredoc contains dangerous rm command"
content.any = ["re:rm\\s+(-[rf]+\\s+)*(-[rf]+|/)"]

# ============================================================================
# REDIRECT RULES
# ============================================================================

# Deny redirects to system paths
[[bash.redirects.deny]]
message = "Cannot write to system paths"
paths = ["path:/etc/**", "path:/usr/**", "path:/bin/**", "path:/sbin/**"]

# Allow redirects within project
[[bash.redirects.allow]]
paths = ["alias:project"]

# Deny append to shell config files
[[bash.redirects.deny]]
message = "Cannot modify shell config"
append = true
paths = ["path:*/.bashrc", "path:*/.zshrc", "path:*/.profile"]

# ============================================================================
# FLAG PATTERN TESTS
# ============================================================================

# Deny chmod with executable bits using flag pattern
# flags[+]:x matches +x, +rx, +rwx etc.
[[bash.deny.chmod]]
message = "Cannot make files executable"
args.any = ["flags[+]:x"]

# Allow chmod without executable bits (including -x to remove)
[[bash.allow.chmod]]

# Deny tar with extract and overwrite using flag pattern
[[bash.deny.tar]]
message = "Cannot extract with overwrite"
args.any = ["flags:xf"]

# Allow tar for listing and creation
[[bash.allow.tar]]
args.any = ["flags:t", "flags:c"]
