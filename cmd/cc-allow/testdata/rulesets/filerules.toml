# File rule integration test ruleset
# Tests that bash commands respect file rules based on their arguments
# This tests the respect_file_rules feature

version = "2.0"

# ============================================================================
# BASH TOOL CONFIGURATION
# ============================================================================

[bash]
default = "allow"
respect_file_rules = true  # Enable checking file rules for command arguments

[bash.allow]
commands = ["cat", "head", "tail", "less", "grep", "wc", "rm", "touch", "cp", "mv", "echo"]

[bash.deny]
commands = ["sudo"]

[bash.redirects]
respect_file_rules = true  # Enable checking file rules for redirect targets

# ============================================================================
# READ TOOL CONFIGURATION - Applied to command arguments
# ============================================================================

[read]
default = "allow"

[read.allow]
paths = [
    "path:/project/**",
    "path:/home/user/**",
    "path:/tmp/**",
]

[read.deny]
paths = [
    "path:**/.ssh/**",
    "path:**/*.key",
    "path:**/*.pem",
    "path:**/.env*",
    "path:/etc/**",
    "path:/secrets/**",
]

# ============================================================================
# WRITE TOOL CONFIGURATION
# ============================================================================

[write]
default = "allow"

[write.allow]
paths = [
    "path:/project/**",
    "path:/tmp/**",
]

[write.deny]
paths = [
    "path:/etc/**",
    "path:/usr/**",
    "path:/bin/**",
    "path:/protected/**",
    "path:**/.ssh/**",
    "path:**/*.key",
]

# ============================================================================
# EDIT TOOL CONFIGURATION
# ============================================================================

[edit]
default = "allow"

[edit.allow]
paths = [
    "path:/project/**",
]

[edit.deny]
paths = [
    "path:/etc/**",
    "path:**/.env*",
]

# ============================================================================
# SPECIFIC RULES
# ============================================================================

# cp: position 0 = source (read rules), position 1 = dest (write rules)
[[bash.allow.cp]]
args.position = { "0" = "ref:read.allow.paths", "1" = "ref:write.allow.paths" }

# Deny cp if source matches read.deny or dest matches write.deny
# Both positions specified for equal specificity (tie-break: deny wins)
[[bash.deny.cp]]
message = "Cannot copy from denied source"
args.position = { "0" = "ref:read.deny.paths", "1" = "path:**" }

[[bash.deny.cp]]
message = "Cannot copy to denied destination"
args.position = { "0" = "path:**", "1" = "ref:write.deny.paths" }

# mv: position 0 = source (read rules), position 1 = dest (write rules)
[[bash.allow.mv]]
args.position = { "0" = "ref:read.allow.paths", "1" = "ref:write.allow.paths" }

# Deny mv if source matches read.deny or dest matches write.deny
# Both positions specified for equal specificity (tie-break: deny wins)
[[bash.deny.mv]]
message = "Cannot move from denied source"
args.position = { "0" = "ref:read.deny.paths", "1" = "path:**" }

[[bash.deny.mv]]
message = "Cannot move to denied destination"
args.position = { "0" = "path:**", "1" = "ref:write.deny.paths" }

# tar: disable file rule checking for complex command
[[bash.allow.tar]]
respect_file_rules = false

# Custom command with Write access type override
[[bash.allow.mywrite]]
file_access_type = "Write"
