# Specificity test ruleset
# Tests CSS-like specificity scoring and tie-breaking behavior
#
# Scoring reference:
#   Exact command (no prefix): +100
#   Pattern command (path:, re:, path:): +0
#   Each args.position entry: +20
#   Each args.contains entry: +10
#   Each args.any_match/all_match entry: +5
#   Each exact pipe.to/from entry: +10
#   Each pattern pipe.to/from entry: +5

version = "1.0"

[policy]
default = "ask"
dynamic_commands = "ask"

[constructs]
subshells = "allow"
heredocs = "allow"

# =============================================================================
# TEST 1: Named command vs wildcard
# =============================================================================
# Wildcard rule: specificity = 0
[[allow."path:*"]]
message = "wildcard allow (spec=0)"

# Named command rule: specificity = 100
# Should win over wildcard
[[deny.test1]]
message = "named command deny (spec=100)"

# =============================================================================
# TEST 2: Tie-breaking - equal specificity, different actions
# =============================================================================
# Both rules have specificity = 100 (named command only)
# Tie-breaker: deny (2) > ask (1) > allow (0)

[[allow.test2]]
message = "test2 allow (spec=100)"

[[deny.test2]]
message = "test2 deny (spec=100) - should win tie"

# =============================================================================
# TEST 3: Tie-breaking - three rules, same specificity
# =============================================================================
# All have specificity = 100, deny should win

[[allow.test3]]
message = "test3 allow"

[[ask.test3]]
message = "test3 ask"

[[deny.test3]]
message = "test3 deny - should win"

# =============================================================================
# TEST 4: args.contains (10 each) vs args.any_match (5 each)
# =============================================================================
# Rule with 2x args.contains: 100 + 20 = 120
[[deny.test4]]
message = "contains x2 (spec=120)"
args.contains = ["-f", "-r"]

# Rule with 2x args.any_match: 100 + 10 = 110
# Should lose to contains rule
[[allow.test4]]
message = "any_match x2 (spec=110)"
args.any_match = ["path:*.txt", "path:*.log"]

# =============================================================================
# TEST 5: Single position vs multiple any_match
# =============================================================================
# 1 position: 100 + 20 = 120
[[deny.test5]]
message = "position x1 (spec=120)"
args.position = { "0" = "dangerous" }

# 4 any_match: 100 + 20 = 120 (same!)
# Tie-break: deny > allow, but first rule is already deny
[[allow.test5]]
message = "any_match x4 (spec=120)"
args.any_match = ["a", "b", "c", "d"]

# =============================================================================
# TEST 6: Multiple position entries accumulate
# =============================================================================
# 3 positions: 100 + 60 = 160
[[allow.test6]]
message = "position x3 (spec=160) - should win"
args.position = { "0" = "safe", "1" = "args", "2" = "here" }

# 1 position: 100 + 20 = 120
[[deny.test6]]
message = "position x1 (spec=120)"
args.position = { "0" = "safe" }

# =============================================================================
# TEST 7: Named pipe.from (10) vs wildcard pipe.from (5)
# =============================================================================
# Named pipe.from: 100 + 10 = 110
[[deny.test7]]
message = "named pipe.from (spec=110) - should win"
pipe.from = ["curl"]

# Wildcard pipe.from: 100 + 5 = 105
[[allow.test7]]
message = "wildcard pipe.from (spec=105)"
pipe.from = ["path:*"]

# =============================================================================
# TEST 8: Combination - command + args + pipe
# =============================================================================
# Full combo: 100 + 20 + 10 + 10 = 140
[[allow.test8]]
message = "full combo (spec=140) - should win"
args.position = { "0" = "run" }
args.contains = ["--safe"]
pipe.from = ["echo"]

# Partial combo: 100 + 20 = 120
[[deny.test8]]
message = "partial combo (spec=120)"
args.position = { "0" = "run" }

# =============================================================================
# TEST 9: Wildcard with high args specificity vs named with low
# =============================================================================
# Wildcard + 3 positions: 0 + 60 = 60
[[allow."path:*"]]
message = "wildcard + positions (spec=60)"
args.position = { "0" = "x", "1" = "y", "2" = "z" }

# Named command only: 100
# Should win because named command weight is high
[[deny.test9]]
message = "named only (spec=100) - should win"

# =============================================================================
# TEST 10: args.all_match accumulates like any_match
# =============================================================================
# 4 all_match patterns: 100 + 20 = 120
[[deny.test10]]
message = "all_match x4 (spec=120)"
args.all_match = ["a", "b", "c", "d"]

# 2 any_match patterns: 100 + 10 = 110
[[allow.test10]]
message = "any_match x2 (spec=110)"
args.any_match = ["a", "b"]

# =============================================================================
# TEST 11: Multiple pipe.from entries accumulate
# =============================================================================
# Use echo/cat/head which are common and won't conflict with other rules

# 3 named pipe sources: 100 + 30 = 130
[[allow.test11]]
message = "pipe.from x3 (spec=130) - should win"
pipe.from = ["echo", "cat", "head"]

# 1 named pipe source: 100 + 10 = 110
[[deny.test11]]
message = "pipe.from x1 (spec=110)"
pipe.from = ["echo"]

# =============================================================================
# TEST 12: pipe.to also contributes to specificity
# =============================================================================
# pipe.to x2: 100 + 20 = 120
[[allow.test12]]
message = "pipe.to x2 (spec=120) - should win"
pipe.to = ["bash", "sh"]

# pipe.to x1: 100 + 10 = 110
[[deny.test12]]
message = "pipe.to x1 (spec=110)"
pipe.to = ["bash"]

# =============================================================================
# TEST 13: Complex real-world scenario
# =============================================================================
# Generic curl deny (network command): spec = 100
[[deny.curl]]
message = "generic curl deny (spec=100)"

# curl to allowed domain: spec = 100 + 5 = 105
# Use regex for URL matching since glob is path-oriented
[[allow.curl]]
message = "curl to localhost (spec=105) - should win"
args.any_match = ["re:localhost"]

# curl with specific flags to localhost: spec = 100 + 10 + 5 = 115
[[allow.curl]]
message = "curl -s to localhost (spec=115) - most specific"
args.contains = ["-s"]
args.any_match = ["re:localhost"]
