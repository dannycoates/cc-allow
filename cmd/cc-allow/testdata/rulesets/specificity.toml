# Specificity test ruleset
# Tests CSS-like specificity scoring and tie-breaking behavior
#
# Scoring reference:
#   Named command (not "*"): +100
#   Each args.position entry: +20
#   Each args.contains entry: +10
#   Each args.any_match/all_match entry: +5
#   Each named pipe.to/from entry: +10
#   pipe.from = ["*"]: +5

[policy]
default = "ask"
dynamic_commands = "ask"

[constructs]
subshells = "allow"
heredocs = "allow"

# =============================================================================
# TEST 1: Named command vs wildcard
# =============================================================================
# Wildcard rule: specificity = 0
[[rule]]
command = "*"
action = "allow"
message = "wildcard allow (spec=0)"

# Named command rule: specificity = 100
# Should win over wildcard
[[rule]]
command = "test1"
action = "deny"
message = "named command deny (spec=100)"

# =============================================================================
# TEST 2: Tie-breaking - equal specificity, different actions
# =============================================================================
# Both rules have specificity = 100 (named command only)
# Tie-breaker: deny (2) > ask (1) > allow (0)

[[rule]]
command = "test2"
action = "allow"
message = "test2 allow (spec=100)"

[[rule]]
command = "test2"
action = "deny"
message = "test2 deny (spec=100) - should win tie"

# =============================================================================
# TEST 3: Tie-breaking - three rules, same specificity
# =============================================================================
# All have specificity = 100, deny should win

[[rule]]
command = "test3"
action = "allow"
message = "test3 allow"

[[rule]]
command = "test3"
action = "ask"
message = "test3 ask"

[[rule]]
command = "test3"
action = "deny"
message = "test3 deny - should win"

# =============================================================================
# TEST 4: args.contains (10 each) vs args.any_match (5 each)
# =============================================================================
# Rule with 2x args.contains: 100 + 20 = 120
[[rule]]
command = "test4"
action = "deny"
message = "contains x2 (spec=120)"
[rule.args]
contains = ["-f", "-r"]

# Rule with 2x args.any_match: 100 + 10 = 110
# Should lose to contains rule
[[rule]]
command = "test4"
action = "allow"
message = "any_match x2 (spec=110)"
[rule.args]
any_match = ["glob:*.txt", "glob:*.log"]

# =============================================================================
# TEST 5: Single position vs multiple any_match
# =============================================================================
# 1 position: 100 + 20 = 120
[[rule]]
command = "test5"
action = "deny"
message = "position x1 (spec=120)"
[rule.args]
position = { "0" = "dangerous" }

# 4 any_match: 100 + 20 = 120 (same!)
# Tie-break: deny > allow, but first rule is already deny
[[rule]]
command = "test5"
action = "allow"
message = "any_match x4 (spec=120)"
[rule.args]
any_match = ["a", "b", "c", "d"]

# =============================================================================
# TEST 6: Multiple position entries accumulate
# =============================================================================
# 3 positions: 100 + 60 = 160
[[rule]]
command = "test6"
action = "allow"
message = "position x3 (spec=160) - should win"
[rule.args]
position = { "0" = "safe", "1" = "args", "2" = "here" }

# 1 position: 100 + 20 = 120
[[rule]]
command = "test6"
action = "deny"
message = "position x1 (spec=120)"
[rule.args]
position = { "0" = "safe" }

# =============================================================================
# TEST 7: Named pipe.from (10) vs wildcard pipe.from (5)
# =============================================================================
# Named pipe.from: 100 + 10 = 110
[[rule]]
command = "test7"
action = "deny"
message = "named pipe.from (spec=110) - should win"
[rule.pipe]
from = ["curl"]

# Wildcard pipe.from: 100 + 5 = 105
[[rule]]
command = "test7"
action = "allow"
message = "wildcard pipe.from (spec=105)"
[rule.pipe]
from = ["*"]

# =============================================================================
# TEST 8: Combination - command + args + pipe
# =============================================================================
# Full combo: 100 + 20 + 10 + 10 = 140
[[rule]]
command = "test8"
action = "allow"
message = "full combo (spec=140) - should win"
[rule.args]
position = { "0" = "run" }
contains = ["--safe"]
[rule.pipe]
from = ["echo"]

# Partial combo: 100 + 20 = 120
[[rule]]
command = "test8"
action = "deny"
message = "partial combo (spec=120)"
[rule.args]
position = { "0" = "run" }

# =============================================================================
# TEST 9: Wildcard with high args specificity vs named with low
# =============================================================================
# Wildcard + 3 positions: 0 + 60 = 60
[[rule]]
command = "*"
action = "allow"
message = "wildcard + positions (spec=60)"
[rule.args]
position = { "0" = "x", "1" = "y", "2" = "z" }

# Named command only: 100
# Should win because named command weight is high
[[rule]]
command = "test9"
action = "deny"
message = "named only (spec=100) - should win"

# =============================================================================
# TEST 10: args.all_match accumulates like any_match
# =============================================================================
# 4 all_match patterns: 100 + 20 = 120
[[rule]]
command = "test10"
action = "deny"
message = "all_match x4 (spec=120)"
[rule.args]
all_match = ["a", "b", "c", "d"]

# 2 any_match patterns: 100 + 10 = 110
[[rule]]
command = "test10"
action = "allow"
message = "any_match x2 (spec=110)"
[rule.args]
any_match = ["a", "b"]

# =============================================================================
# TEST 11: Multiple pipe.from entries accumulate
# =============================================================================
# Use echo/cat/head which are common and won't conflict with other rules

# 3 named pipe sources: 100 + 30 = 130
[[rule]]
command = "test11"
action = "allow"
message = "pipe.from x3 (spec=130) - should win"
[rule.pipe]
from = ["echo", "cat", "head"]

# 1 named pipe source: 100 + 10 = 110
[[rule]]
command = "test11"
action = "deny"
message = "pipe.from x1 (spec=110)"
[rule.pipe]
from = ["echo"]

# =============================================================================
# TEST 12: pipe.to also contributes to specificity
# =============================================================================
# pipe.to x2: 100 + 20 = 120
[[rule]]
command = "test12"
action = "allow"
message = "pipe.to x2 (spec=120) - should win"
[rule.pipe]
to = ["bash", "sh"]

# pipe.to x1: 100 + 10 = 110
[[rule]]
command = "test12"
action = "deny"
message = "pipe.to x1 (spec=110)"
[rule.pipe]
to = ["bash"]

# =============================================================================
# TEST 13: Complex real-world scenario
# =============================================================================
# Generic curl deny (network command): spec = 100
[[rule]]
command = "curl"
action = "deny"
message = "generic curl deny (spec=100)"

# curl to allowed domain: spec = 100 + 5 = 105
# Use regex for URL matching since glob is path-oriented
[[rule]]
command = "curl"
action = "allow"
message = "curl to localhost (spec=105) - should win"
[rule.args]
any_match = ["re:localhost"]

# curl with specific flags to localhost: spec = 100 + 10 + 5 = 115
[[rule]]
command = "curl"
action = "allow"
message = "curl -s to localhost (spec=115) - most specific"
[rule.args]
contains = ["-s"]
any_match = ["re:localhost"]
