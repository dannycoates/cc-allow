# cc-allow Kitchen Sink Configuration (v2)
# This example demonstrates ALL configuration features documented in docs/config.md
# Use this as a reference — don't use it directly as it's intentionally comprehensive

version = "2.0"

# =============================================================================
# ALIASES
# =============================================================================
# Define reusable pattern aliases to reduce repetition

[aliases]
project = "path:$PROJECT_ROOT/**"
plugin = "path:$CLAUDE_PLUGIN_ROOT/**"
sensitive = ["path:$HOME/.ssh/**", "path:**/*.key", "path:**/*.pem"]
system = ["path:/etc/**", "path:/usr/**", "path:/bin/**", "path:/sbin/**"]

# =============================================================================
# BASH TOOL CONFIGURATION
# =============================================================================

[bash]
default = "ask"                    # "allow", "deny", or "ask" for unmatched commands
dynamic_commands = "deny"          # action for $VAR or $(cmd) as command name
default_message = "Command requires approval"
unresolved_commands = "ask"        # "ask" or "deny" for commands not found in PATH
respect_file_rules = true          # check file rules for command arguments (default: true)

# =============================================================================
# SHELL CONSTRUCTS
# =============================================================================

[bash.constructs]
function_definitions = "deny"      # foo() { ... } — prevent function definitions
background = "deny"                # command & — prevent backgrounding
subshells = "ask"                  # (command) — ask for subshells
heredocs = "allow"                 # <<EOF ... EOF — allow heredocs (checked by heredoc rules)

# =============================================================================
# ALLOW/DENY COMMAND LISTS
# =============================================================================

[bash.allow]
commands = [
    # Simple command names
    "ls", "cat", "head", "tail", "grep", "find", "wc", "echo", "pwd", "date",
    "git", "go", "npm", "cargo",

    # Path patterns for location-based matching
    "path:$PROJECT_ROOT/bin/*",        # project-local binaries
    "path:$PROJECT_ROOT/scripts/*",    # project scripts
    "path:/usr/local/bin/*",           # user-installed tools
]

[bash.deny]
commands = [
    # Dangerous system commands
    "sudo", "su", "doas",
    "dd", "mkfs", "fdisk", "parted",
    "shutdown", "reboot", "halt",

    # Commands from untrusted locations
    "path:/tmp/**",                    # deny anything from /tmp
    "path:$HOME/Downloads/**",         # deny from Downloads
]
message = "Dangerous or untrusted command blocked"

# =============================================================================
# RULES — Basic Argument Matching
# =============================================================================

# --- contains: all listed strings must be present ---
[[bash.deny.rm]]
message = "{{.ArgsStr}} — recursive force deletion blocked"
args.contains = ["-rf"]                 # must have exactly "-rf"

# --- any: at least one pattern must match (OR semantics) ---
[[bash.deny.chmod]]
message = "Cannot set world-writable permissions"
args.any = ["777", "666", "re:[0-7][67][67]"]

# --- all: every argument must match one of these (AND semantics) ---
[[bash.allow.touch]]
args.all = ["path:$PROJECT_ROOT/**"]  # only allow touching project files

# --- position: specific argument positions must match ---
[[bash.deny.mv]]
message = "Cannot move files to system directories"
args.position = { "1" = "path:/etc/**" }    # destination is /etc

# =============================================================================
# RULES — Extended Argument Matching
# =============================================================================

# --- Position with enum values (OR semantics) ---
# Using positional nesting for common git subcommands
[[bash.allow.git.status]]
[[bash.allow.git.diff]]
[[bash.allow.git.log]]
[[bash.allow.git.branch]]
[[bash.allow.git.show]]
[[bash.allow.git.blame]]

# Deny network git operations
[[bash.deny.git.push]]
message = "{{.Arg 0}} — network git operations require approval"

[[bash.deny.git.pull]]
message = "{{.Arg 0}} — network git operations require approval"

[[bash.deny.git.fetch]]
message = "{{.Arg 0}} — network git operations require approval"

[[bash.deny.git.clone]]
message = "{{.Arg 0}} — network git operations require approval"

[[bash.allow.docker]]
message = "Safe docker inspection"
# Multi-position enum: subcommand AND flag must both match
args.position = {
    "0" = ["ps", "images", "inspect", "logs", "stats"],
    "1" = ["--format", "-f", "--filter", "--tail", "--help", "-h"]
}

[[bash.deny.docker]]
message = "Destructive docker operations blocked"
args.position = { "0" = ["rm", "rmi", "kill", "stop", "prune", "system prune"] }

# --- any with sequence objects (adjacent argument matching) ---
[[bash.allow.ffmpeg]]
message = "ffmpeg with safe input source"
args.any = [
    # Sequence: -i followed by $HOME path
    { "0" = "-i", "1" = "path:$HOME/**" },
    # Sequence: -i followed by project path
    { "0" = "-i", "1" = "path:$PROJECT_ROOT/**" },
    # String pattern: help flag
    "re:^-(-help|h)$"
]

[[bash.deny.ffmpeg]]
message = "ffmpeg cannot read from system directories"
args.any = [
    { "0" = "-i", "1" = "path:/etc/**" },
    { "0" = "-i", "1" = "path:/sys/**" },
    { "0" = "-i", "1" = "path:/proc/**" }
]

# --- all with sequences (multiple required pairs) ---
[[bash.allow.openssl]]
message = "openssl with proper certificate handling"
args.all = [
    # Must have -in with cert file
    { "0" = "-in", "1" = ["path:*.pem", "path:*.crt", "path:*.key", "path:*.der"] },
    # AND must have -out with cert file
    { "0" = "-out", "1" = ["path:*.pem", "path:*.crt", "path:*.der"] }
]

# --- 3-position sequence ---
[[bash.allow.rsync]]
message = "rsync with safe flags"
args.any = [
    { "0" = "-a", "1" = "-v", "2" = "--progress" },
    { "0" = "-avz", "1" = "--progress" }
]

# =============================================================================
# RULES — Pipe Context
# =============================================================================

# Block shells receiving piped input from download commands
[[bash.deny.bash]]
message = "{{.Command}} receiving from {{index .PipesFrom 0}} — piping to shell blocked"
pipe.from = ["curl", "wget", "nc", "netcat"]

[[bash.deny.sh]]
message = "sh cannot receive piped input from network tools"
pipe.from = ["curl", "wget", "nc", "netcat"]

# Block eval from receiving ANY piped input
[[bash.deny.eval]]
message = "eval cannot receive piped input"
pipe.from = ["path:*"]

# Block curl from piping to dangerous sinks
[[bash.deny.curl]]
message = "curl cannot pipe to shell or eval"
pipe.to = ["bash", "sh", "zsh", "eval", "source"]

# =============================================================================
# RULES — Pattern Types
# =============================================================================

# --- path: patterns ---
[[bash.deny.cat]]
message = "Cannot read key files"
args.any = ["path:**/*.key", "path:**/*.pem", "path:**/.env*"]

# --- re: regex patterns ---
[[bash.deny.grep]]
message = "Cannot search for sensitive patterns"
args.any = ["re:(?i)(password|secret|token|api.?key)"]

# --- path: patterns with variable expansion ---
[[bash.allow.rm]]
message = "rm allowed in project directory"
args.any = ["path:$PROJECT_ROOT/**"]

[[bash.deny.rm]]
message = "Cannot delete files outside project — {{.ArgsStr}}"

# --- flags: patterns ---
[[bash.deny.tar]]
message = "tar extract blocked (use explicit extraction)"
args.any = ["flags:x", "flags:xf", "flags:xzf", "flags:xjf"]

[[bash.allow.tar]]
message = "tar create/list allowed"
args.any = ["flags:c", "flags:t", "flags:cf", "flags:tf"]

[[bash.deny.chmod]]
message = "Cannot add execute permission"
args.any = ["flags[+]:x"]          # matches +x, +rx, +rwx

# --- Negation ---
[[bash.allow.find]]
# Allow find only in project root (negated: NOT outside project)
args.any = ["path:$PROJECT_ROOT/**"]
# Alternative with negation: args.any = ["!path:/etc/**", "!path:/usr/**"]

# =============================================================================
# RULES — Per-Rule File Configuration
# =============================================================================

# Disable file rule checking for tar (complex argument patterns)
[[bash.allow.tar]]
respect_file_rules = false

# Force specific access type for custom command
[[bash.allow.mybackup]]
file_access_type = "Read"          # check all file args against Read rules

# =============================================================================
# RULES — Positional File Rules with ref:
# =============================================================================

# cp: source is Read, destination is Write
[[bash.allow.cp]]
args.position = { "0" = "ref:read.allow.paths", "1" = "ref:write.allow.paths" }

# mv: same pattern as cp
[[bash.allow.mv]]
args.position = { "0" = "ref:read.allow.paths", "1" = "ref:write.allow.paths" }

# install: source is Read, destination is Write
[[bash.allow.install]]
args.position = { "0" = "ref:read.allow.paths", "1" = "ref:write.allow.paths" }

# =============================================================================
# REDIRECTS
# =============================================================================

[bash.redirects]
respect_file_rules = true          # check file rules for redirect targets

# Allow redirects to safe locations
[[bash.redirects.allow]]
paths = ["/dev/null", "/dev/stderr", "/dev/stdout"]

[[bash.redirects.allow]]
paths = ["path:$PROJECT_ROOT/**", "path:/tmp/**"]

# Deny redirects to system directories
[[bash.redirects.deny]]
message = "Cannot redirect to {{.Target}} — system directory"
paths = ["path:/etc/**", "path:/usr/**", "path:/bin/**", "path:/sbin/**"]

# Deny appending to shell config files
[[bash.redirects.deny]]
message = "Cannot append to shell config: {{.TargetFileName}}"
append = true                      # only match >> (append mode)
paths = [".bashrc", ".zshrc", ".profile", ".bash_profile", "path:*/.bashrc", "path:*/.zshrc", "path:*/.profile"]

# =============================================================================
# HEREDOCS
# =============================================================================

# Deny heredocs with dangerous content patterns
[[bash.heredocs.deny]]
message = "Heredoc contains dangerous SQL"
content.any = ["re:(?i)DROP\\s+TABLE", "re:(?i)DELETE\\s+FROM", "re:(?i)TRUNCATE"]

[[bash.heredocs.deny]]
message = "Heredoc contains shell injection patterns"
content.any = [
    "re:\\$\\(.*\\)",              # command substitution
    "re:`.*`",                      # backtick execution
    "re:rm\\s+-rf",                 # recursive delete
    "re:/dev/tcp/",                 # bash network
]

[[bash.heredocs.deny]]
message = "Heredoc contains privilege escalation"
content.any = ["re:(?m)^\\s*(sudo|su)\\s"]

# =============================================================================
# FILE TOOL PERMISSIONS
# =============================================================================

[read]
default = "ask"                    # when no rules match

[read.allow]
paths = [
    "path:$PROJECT_ROOT/**",
    "path:$HOME/Documents/**",
    "path:$HOME/code/**",
    "path:/tmp/**",
    "path:**/*.md",                # markdown anywhere
    "path:**/*.txt",               # text files anywhere
]

[read.deny]
paths = [
    # Sensitive directories
    "path:$HOME/.ssh/**",
    "path:$HOME/.gnupg/**",
    "path:$HOME/.aws/**",
    "path:/etc/shadow",
    "path:/etc/sudoers",
    "/secrets/**",

    # Sensitive file patterns
    "path:**/*.key",
    "path:**/*.pem",
    "path:**/.env*",
    "path:**/*credentials*",
    "path:**/*password*",
    "re:.*\\.(key|pem|p12|pfx)$",
]
message = "Cannot read {{.FilePath}} — sensitive file"

[edit]
default = "ask"

[edit.allow]
paths = [
    "path:$PROJECT_ROOT/**",
]

[edit.deny]
paths = [
    "path:$HOME/.*",               # dotfiles
    "path:**/.env*",
    "path:**/*.key",
]
message = "Cannot edit {{.FileName}} in {{.FileDir}}"

[write]
default = "ask"

[write.allow]
paths = [
    "path:$PROJECT_ROOT/**",
    "path:/tmp/**",
]

[write.deny]
paths = [
    # System directories
    "path:/etc/**",
    "path:/usr/**",
    "path:/bin/**",
    "path:/sbin/**",
    "path:/var/**",
    "/protected/**",

    # Home sensitive areas
    "path:$HOME/.ssh/**",
    "path:$HOME/.gnupg/**",
    "path:$HOME/.*",               # dotfiles

    # Sensitive patterns
    "path:**/*.key",
    "path:**/*.pem",
]
message = "Cannot write to {{.FilePath}} — {{.FileDir}} is protected"

# =============================================================================
# MESSAGE TEMPLATES — Examples
# =============================================================================

# Templates are shown in context above, here are more examples:

# Show full command with all arguments
# message = "{{.ArgsStr}} — not allowed"

# Show specific positional argument
# message = "Cannot {{.Arg 0}} to {{.Arg 1}}"

# Show resolved path
# message = "{{.ResolvedPath}} — untrusted location"

# Show pipe context
# message = "{{.Command}} receiving from {{index .PipesFrom 0}}"

# Redirect context
# message = "Cannot write to {{.TargetFileName}} in {{.TargetDir}}"

# File context
# message = "Cannot {{.Tool}} {{.FileName}} — protected"

# Environment variables
# message = "Outside {{.ProjectRoot}} — blocked"
